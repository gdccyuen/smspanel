# Feature Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:subagent-driven-development to implement this plan task-by-task.

**Goal:** Implement 5 new features: database index, admin query UI, error response standardization, logging standardization, and health check endpoint.

**Architecture:** Each feature is independent but builds on common utilities (error formatting, logging).

**Tech Stack:** Flask-SQLAlchemy, standard logging, Flask blueprints.

---

## Task 1: Add Compound Index on Message Model

**Files:**
- Modify: `src/smspanel/models.py:78-88` (Message model)

**Step 1: Write the failing test**

```python
# tests/test_indexes.py
def test_message_compound_index_exists():
    """Message table should have compound index on (user_id, created_at)."""
    from smspanel.models import Message
    from smspanel.extensions import db

    # Get the actual table
    table = Message.__table__

    # Check if compound index exists
    indexes = [idx.name for idx in table.indexes]

    # user_id has an index, created_at has an index
    # We need a compound index on (user_id, created_at)
    has_user_id_idx = any("user_id" in idx for idx in indexes)
    has_created_at_idx = any("created_at" in idx for idx in indexes)
    has_compound_idx = any(
        "ix_messages_user_id_created_at" == idx or
        (set(["user_id", "created_at"]).issubset(set(idx.columns)))
        for idx in table.indexes
    )

    assert has_compound_idx, "Compound index on (user_id, created_at) should exist"
```

**Step 2: Run test before fix**

Run: `pytest tests/test_indexes.py -v`
Expected: FAIL (no compound index yet)

**Step 3: Add compound index to Message model**

In `src/smspanel/models.py`, update the Message class:

```python
class Message(db.Model):
    """Message model for SMS messages."""

    __tablename__ = "messages"
    __table_args__ = (
        db.Index("ix_messages_user_id_created_at", "user_id", "created_at"),
    )

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"), nullable=False)
    content = db.Column(db.Text, nullable=False)
    status = db.Column(
        db.String(20), default=MessageStatus.PENDING, index=True
    )
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))
    sent_at = db.Column(db.DateTime, nullable=True)
    hkt_response = db.Column(db.Text, nullable=True)
```

Note: Remove `index=True` from `user_id` since it's now part of the compound index.

**Step 4: Run test after fix**

Run: `pytest tests/test_indexes.py -v`
Expected: PASS

**Step 5: Create migration script**

Create `scripts/add_message_compound_index.py`:
```python
"""Migration script to add compound index on messages table."""

from flask import Flask
from smspanel import create_app
from smspanel.extensions import db

def migrate():
    app = create_app()
    with app.app_context():
        # Add compound index
        db.session.execute(
            "CREATE INDEX IF NOT EXISTS ix_messages_user_id_created_at ON messages (user_id, created_at)"
        )
        db.session.commit()
        print("Compound index added successfully")

if __name__ == "__main__":
    migrate()
```

**Step 6: Run tests**

Run: `pytest -v`
Expected: All tests pass

**Step 7: Commit**

```bash
git add src/smspanel/models.py tests/test_indexes.py scripts/add_message_compound_index.py
git commit -m "feat: add compound index on Message(user_id, created_at)"
```

---

## Task 2: Add Admin Message Query UI

**Files:**
- Create: `src/smspanel/templates/admin/messages.html`
- Create: `src/smspanel/web/admin_messages.py`
- Modify: `src/smspanel/web/__init__.py` (register blueprint)
- Create: `tests/test_admin_messages.py`

**Step 1: Write the failing test**

```python
# tests/test_admin_messages.py
def test_admin_messages_route_exists():
    """Admin messages route should exist."""
    from flask import Flask
    from smspanel import create_app

    app = create_app()
    with app.test_client() as client:
        # Login as admin
        with app.app_context():
            from smspanel.models import User
            admin = User.query.filter_by(username="SMSadmin").first()
            if admin:
                admin.is_active = True
                db.session.commit()

        # Test route exists
        response = client.get("/admin/messages", follow_redirects=True)
        # Should return 200 or redirect to login
        assert response.status_code in [200, 302]


def test_admin_messages_route_requires_admin():
    """Admin messages route should require admin privileges."""
    from flask import Flask
    from smspanel import create_app

    app = create_app()
    with app.test_client() as client:
        # Test without login - should redirect to login
        response = client.get("/admin/messages", follow_redirects=True)
        assert b"login" in response.data.lower() or response.status_code == 302
```

**Step 2: Run test before fix**

Run: `pytest tests/test_admin_messages.py -v`
Expected: FAIL (route doesn't exist)

**Step 3: Create admin_messages.py**

Create `src/smspanel/web/admin_messages.py`:

```python
"""Admin routes for message management and querying."""

from datetime import datetime, timezone, timedelta
from flask import Blueprint, request, render_template
from flask_login import login_required, current_user
from werkzeug.wrappers import Response

from smspanel.models import User, Message
from smspanel.utils.database import db_transaction

web_admin_messages_bp = Blueprint("web_admin_messages", __name__, url_prefix="/admin/messages")


@web_admin_messages_bp.route("")
@login_required
def messages():
    """List messages with filters for admin."""
    if not current_user.is_admin:
        return Response("Forbidden", status=403)

    # Filters
    user_id = request.args.get("user_id", type=int)
    status = request.args.get("status")
    start_date = request.args.get("start_date")
    end_date = request.args.get("end_date")
    page = request.args.get("page", 1, type=int)
    per_page = 50

    # Build query
    query = Message.query

    if user_id:
        query = query.filter_by(user_id=user_id)

    if status:
        query = query.filter_by(status=status)

    if start_date:
        start_dt = datetime.fromisoformat(start_date)
        query = query.filter(Message.created_at >= start_dt)

    if end_date:
        end_dt = datetime.fromisoformat(end_date)
        query = query.filter(Message.created_at <= end_dt)

    # Get total count before pagination
    total_count = query.count()

    # Paginate
    messages = query.order_by(Message.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )

    # Get users for filter dropdown
    users = User.query.order_by(User.username.asc()).all()

    return render_template(
        "admin/messages.html",
        messages=messages,
        users=users,
        total_count=total_count,
        user_id=user_id,
        status=status,
        start_date=start_date,
        end_date=end_date,
    )
```

**Step 4: Create admin_messages.html template**

Create `src/smspanel/templates/admin/messages.html`:

```html
{% extends "base.html" %}

{% block title %}Message Query - SMS Application{% endblock %}

{% block content %}
<div class="admin-messages">
    <div class="admin-header">
        <h1>Message Query</h1>
        <p>Query messages by user, status, or date range</p>
    </div>

    <!-- Filters -->
    <div class="filter-form">
        <form method="GET" action="{{ url_for('web_admin_messages.messages') }}">
            <div class="form-row">
                <div class="form-group">
                    <label for="user_id">User</label>
                    <select name="user_id" id="user_id">
                        <option value="">All Users</option>
                        {% for user in users %}
                        <option value="{{ user.id }}" {{ 'selected' if user_id == user.id }}>
                            {{ user.username }} (ID: {{ user.id }})
                        </option>
                        {% endfor %}
                    </select>
                </div>

                <div class="form-group">
                    <label for="status">Status</label>
                    <select name="status" id="status">
                        <option value="">All Statuses</option>
                        <option value="pending" {{ 'selected' if status == 'pending' }}>Pending</option>
                        <option value="sent" {{ 'selected' if status == 'sent' }}>Sent</option>
                        <option value="failed" {{ 'selected' if status == 'failed' }}>Failed</option>
                        <option value="partial" {{ 'selected' if status == 'partial' }}>Partial</option>
                    </select>
                </div>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label for="start_date">Start Date</label>
                    <input type="datetime-local" name="start_date" id="start_date"
                           value="{{ start_date if start_date else '' }}">
                </div>

                <div class="form-group">
                    <label for="end_date">End Date</label>
                    <input type="datetime-local" name="end_date" id="end_date"
                           value="{{ end_date if end_date else '' }}">
                </div>
            </div>

            <button type="submit" class="btn btn-primary">Search</button>
            <a href="{{ url_for('web_admin_messages.messages') }}" class="btn btn-secondary">Clear</a>
        </form>
    </div>

    <!-- Results -->
    <div class="results-info">
        <p>Found {{ total_count }} messages</p>
    </div>

    <!-- Messages Table -->
    <div class="table-container">
        <table class="data-table">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>User</th>
                    <th>Content</th>
                    <th>Status</th>
                    <th>Recipients</th>
                    <th>Created</th>
                </tr>
            </thead>
            <tbody>
                {% for msg in messages.items %}
                <tr class="status-{{ msg.status }}">
                    <td>{{ msg.id }}</td>
                    <td>
                        {% if msg.user %}
                        <a href="{{ url_for('web_admin_messages.messages', user_id=msg.user_id) }}">
                            {{ msg.user.username }}
                        </a>
                        {% else %}
                        User {{ msg.user_id }}
                        {% endif %}
                    </td>
                    <td>{{ msg.content[:50] }}{% if msg.content|length > 50 %}...{% endif %}</td>
                    <td>
                        <span class="status-badge {{ msg.status }}">{{ msg.status }}</span>
                    </td>
                    <td>{{ msg.recipient_count }} ({{ msg.success_count }}/{{ msg.recipient_count }})</td>
                    <td>{{ msg.created_at|hkt }}</td>
                </tr>
                {% else %}
                <tr>
                    <td colspan="6" class="empty-state">No messages found.</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>

    <!-- Pagination -->
    {% if messages.pages > 1 %}
    <div class="pagination">
        {% for p in range(1, messages.pages + 1) %}
        <a href="{{ url_for('web_admin_messages.messages', page=p, user_id=user_id, status=status, start_date=start_date, end_date=end_date) }}"
           class="btn {{ 'btn-primary' if p == page else 'btn-secondary' }}">
            {{ p }}
        </a>
        {% endfor %}
    </div>
    {% endif %}
</div>
{% endblock %}
```

**Step 4: Update web/__init__.py**

Modify `src/smspanel/web/__init__.py`:

```python
from . import auth, sms, admin, dead_letter
from . import admin_messages  # Add this line
```

**Step 5: Run test after fix**

Run: `pytest tests/test_admin_messages.py -v`
Expected: PASS

**Step 6: Run full test suite**

Run: `pytest -v`
Expected: All tests pass

**Step 7: Commit**

```bash
git add src/smspanel/web/admin_messages.py src/smspanel/templates/admin/messages.html src/smspanel/web/__init__.py tests/test_admin_messages.py
git commit -m "feat: add admin message query UI with filters"
```

---

## Task 3: Standardize Error Response Format

**Files:**
- Modify: `src/smspanel/api/responses.py`
- Modify: `src/smspanel/api/sms.py`
- Modify: `src/smspanel/api/decorators.py`
- Create: `tests/test_error_format.py`

**Step 1: Write the failing test**

```python
# tests/test_error_format.py
def test_error_response_has_nested_format():
    """Error responses should use nested {error: {...}} format."""
    from smspanel.api.responses import APIResponse

    # Test error response format
    response, status = APIResponse.error("Test error", 400, "TEST_ERROR")
    data = response.get_json()

    # New format: {"error": {"code": "TEST_ERROR", "message": "Test error"}}
    assert "error" in data
    assert isinstance(data["error"], dict)
    assert data["error"]["code"] == "TEST_ERROR"
    assert data["error"]["message"] == "Test error"
    assert "success" not in data  # No success field in error response
```

**Step 2: Run test before fix**

Run: `pytest tests/test_error_format.py -v`
Expected: FAIL (current format doesn't match)

**Step 3: Update APIResponse.error()**

Modify `src/smspanel/api/responses.py`:

```python
@staticmethod
def error(message: str, status_code: int = 400, error_code: str | None = None) -> tuple:
    """Return an error response.

    New format:
    {
        "error": {
            "code": "ERROR_CODE",
            "message": "Human-readable error message"
        }
    }

    Args:
        message: Error message.
        status_code: HTTP status code (default: 400).
        error_code: Optional machine-readable error code.

    Returns:
        JSON error response tuple.
    """
    error_dict: dict[str, Any] = {"message": message}
    if error_code:
        error_dict["code"] = error_code

    return jsonify({"error": error_dict}), status_code
```

**Step 4: Update helper functions**

Modify helper functions in `src/smspanel/api/responses.py` to pass error_code:

```python
def unauthorized(message: str = "Unauthorized", error_code: str = "UNAUTHORIZED") -> tuple:
    """Return unauthorized error (401)."""
    return APIResponse.error(message, 401, error_code)


def bad_request(message: str = "Bad request", error_code: str = "BAD_REQUEST") -> tuple:
    """Return bad request error (400)."""
    return APIResponse.error(message, 400, error_code)


def not_found(message: str = "Resource not found", error_code: str = "NOT_FOUND") -> tuple:
    """Return not found error (404)."""
    return APIResponse.error(message, 404, error_code)


def service_unavailable(
    message: str = "Service is busy, please try again later",
    error_code: str = "SERVICE_UNAVAILABLE",
) -> tuple:
    """Return service unavailable error (503)."""
    return APIResponse.error(message, 503, error_code)


def internal_server_error(
    message: str = "Internal server error", error_code: str = "INTERNAL_SERVER_ERROR"
) -> tuple:
    """Return internal server error (500)."""
    return APIResponse.error(message, 500, error_code)
```

**Step 5: Run test after fix**

Run: `pytest tests/test_error_format.py -v`
Expected: PASS

**Step 6: Run full test suite**

Run: `pytest -v`
Expected: All tests pass

**Step 7: Commit**

```bash
git add src/smspanel/api/responses.py src/smspanel/api/decorators.py tests/test_error_format.py
git commit -m "refactor: standardize error responses to {error: {...}} format"
```

---

## Task 4: Standardize Error Logging

**Files:**
- Create: `src/smspanel/utils/logging.py`
- Modify: `src/smspanel/app.py` (setup logging)
- Modify: `src/smspanel/api/decorators.py` (use new logging)
- Create: `tests/test_logging.py`

**Step 1: Write the failing test**

```python
# tests/test_logging.py
def test_logging_module_exists():
    """Logging utility module should exist."""
    from smspanel.utils.logging import log_error, log_request

    assert log_error is not None
    assert log_request is not None


def test_log_error_function():
    """log_error should handle errors with proper formatting."""
    from smspanel.utils.logging import log_error
    import logging

    # Should not raise
    try:
        raise ValueError("Test error")
    except ValueError as e:
        log_error(e, {"extra": "data"})
```

**Step 2: Run test before fix**

Run: `pytest tests/test_logging.py -v`
Expected: FAIL (module doesn't exist)

**Step 3: Create logging utility**

Create `src/smspanel/utils/logging.py`:

```python
"""Standardized logging utilities."""

import logging
import traceback
import uuid
from datetime import datetime, timezone
from typing import Any, Optional

from flask import Flask, Request


# Request ID context
_request_id_context: Optional[str] = None


def get_request_id() -> str:
    """Get current request ID or generate one."""
    global _request_id_context
    return _request_id_context or "N/A"


def set_request_id(request_id: str) -> None:
    """Set request ID for context."""
    global _request_id_context
    _request_id_context = request_id


def setup_app_logging(app: Flask) -> None:
    """Configure application-wide logging.

    Args:
        app: Flask application instance.
    """
    # Configure root logger
    log_level = app.config.get("LOG_LEVEL", logging.INFO)
    log_format = "%(asctime)s - %(name)s - %(levelname)s - [%(request_id)s] %(message)s"

    # Create request ID filter
    class RequestIdFilter(logging.Filter):
        def filter(self, record):
            record.request_id = get_request_id()
            return True

    # Configure handler
    handler = logging.StreamHandler()
    handler.setFormatter(logging.Formatter(log_format))
    handler.addFilter(RequestIdFilter())

    # Get root logger and configure
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)
    root_logger.addHandler(handler)

    # Configure app-specific logger
    app_logger = logging.getLogger("smspanel")
    app_logger.setLevel(log_level)


def log_error(
    error: Exception,
    context: Optional[dict[str, Any]] = None,
    level: int = logging.ERROR,
    exc_info: bool = True,
) -> None:
    """Log an error with standardized format.

    Args:
        error: The exception to log.
        context: Optional context dictionary with additional details.
        level: Logging level (default: ERROR).
        exc_info: Include traceback (default: True).
    """
    logger = logging.getLogger("smspanel")

    extra = {"request_id": get_request_id()}

    log_message = {
        "error_type": type(error).__name__,
        "error_message": str(error),
        "context": context or {},
        "request_id": get_request_id(),
    }

    if exc_info:
        logger.log(level, f"Error: {error}", extra=extra, exc_info=True)
    else:
        logger.log(level, f"Error: {error}", extra=extra)


def log_request(request: Request, status_code: int, duration_ms: float) -> None:
    """Log an HTTP request with standardized format.

    Args:
        request: Flask request object.
        status_code: HTTP status code of response.
        duration_ms: Request duration in milliseconds.
    """
    logger = logging.getLogger("smspanel")

    log_data = {
        "method": request.method,
        "path": request.path,
        "status_code": status_code,
        "duration_ms": duration_ms,
        "request_id": get_request_id(),
        "ip": request.remote_addr,
    }

    if status_code >= 400:
        logger.warning(f"Request failed: {request.method} {request.path} -> {status_code}", extra=log_data)
    else:
        logger.info(f"Request: {request.method} {request.path} -> {status_code}", extra=log_data)


def generate_request_id() -> str:
    """Generate a unique request ID."""
    return str(uuid.uuid4())[:8]
```

**Step 4: Update app.py to setup logging**

Modify `src/smspanel/app.py`, add after `_load_config`:

```python
def create_app(config_name: Optional[str] = None) -> Flask:
    """Create and configure Flask application."""
    app = Flask(__name__, template_folder="templates", static_folder="../static")

    # Load configuration
    _load_config(app, config_name)

    # Setup logging (add this line after _load_config)
    _setup_logging(app)

    # ... rest of function
```

Add new function:

```python
def _setup_logging(app: Flask) -> None:
    """Configure application logging."""
    from smspanel.utils.logging import setup_app_logging

    setup_app_logging(app)
```

**Step 5: Add request logging middleware**

Modify `src/smspanel/app.py`, update `_register_blueprints`:

```python
def _register_blueprints(app: Flask) -> None:
    """Register Flask blueprints."""
    from smspanel.api import api_bp
    from smspanel.web import web_bp

    # Add before/after request handlers for logging
    @app.before_request
    def before_request():
        from smspanel.utils.logging import set_request_id, generate_request_id
        request_id = request.headers.get("X-Request-ID") or generate_request_id()
        set_request_id(request_id)
        g.start_time = datetime.now(timezone.utc)

    @app.after_request
    def after_request(response):
        from smspanel.utils.logging import log_request
        from flask import g
        import time

        if hasattr(g, "start_time"):
            duration_ms = (datetime.now(timezone.utc) - g.start_time).total_seconds() * 1000
        else:
            duration_ms = 0

        log_request(request, response.status_code, duration_ms)
        return response

    app.register_blueprint(api_bp, url_prefix="/api")
    app.register_blueprint(web_bp)
```

Note: Need to import `flask.g` and `flask.request` at top of file.

**Step 6: Run test after fix**

Run: `pytest tests/test_logging.py -v`
Expected: PASS

**Step 7: Run full test suite**

Run: `pytest -v`
Expected: All tests pass

**Step 8: Commit**

```bash
git add src/smspanel/utils/logging.py src/smspanel/app.py tests/test_logging.py
git commit -m "feat: add standardized error logging"
```

---

## Task 5: Add Health Check Endpoint

**Files:**
- Create: `src/smspanel/api/health.py`
- Modify: `src/smspanel/api/__init__.py` (register blueprint)
- Create: `tests/test_health.py`

**Step 1: Write the failing test**

```python
# tests/test_health.py
def test_health_endpoint_exists():
    """Health check endpoint should exist."""
    from flask import Flask
    from smspanel import create_app

    app = create_app()
    with app.test_client() as client:
        response = client.get("/api/health")
        assert response.status_code == 200

        data = response.get_json()
        assert "status" in data
        assert data["status"] in ["healthy", "unhealthy"]


def test_health_endpoint_returns_details():
    """Health check should return system details."""
    from flask import Flask
    from smspanel import create_app

    app = create_app()
    with app.test_client() as client:
        response = client.get("/api/health")
        data = response.get_json()

        # Should include key health indicators
        assert "timestamp" in data
        assert "database" in data
        assert "version" in data
```

**Step 2: Run test before fix**

Run: `pytest tests/test_health.py::test_health_endpoint_exists -v`
Expected: FAIL (endpoint doesn't exist)

**Step 3: Create health.py**

Create `src/smspanel/api/health.py`:

```python
"""Health check endpoint for monitoring and load balancers."""

from flask import Blueprint, jsonify
from datetime import datetime, timezone
import os
import sys

from smspanel import db
from smspanel.config import config as config_dict


api_health_bp = Blueprint("api_health", __name__)


@api_health_bp.route("/health", methods=["GET"])
def health_check():
    """Health check endpoint for monitoring.

    Returns:
        JSON response with health status and system information.
    """
    checks = {
        "database": _check_database(),
        "memory": _check_memory(),
    }

    # Determine overall status
    all_healthy = all(check["healthy"] for check in checks.values())
    overall_status = "healthy" if all_healthy else "unhealthy"

    response_data = {
        "status": overall_status,
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "version": _get_version(),
        "checks": checks,
    }

    status_code = 200 if all_healthy else 503

    return jsonify(response_data), status_code


def _check_database() -> dict:
    """Check database connectivity.

    Returns:
        Health check result dictionary.
    """
    try:
        # Execute a simple query
        db.session.execute(db.text("SELECT 1"))
        return {"healthy": True, "message": "Connected"}
    except Exception as e:
        return {"healthy": False, "message": str(e)}


def _check_memory() -> dict:
    """Check memory usage.

    Returns:
        Health check result dictionary.
    """
    try:
        import psutil

        process = psutil.Process(os.getpid())
        mem_info = process.memory_info()
        memory_mb = mem_info.rss / (1024 * 1024)

        return {
            "healthy": memory_mb < 500,  # Less than 500MB
            "message": f"{memory_mb:.1f} MB used",
            "used_mb": round(memory_mb, 1),
        }
    except ImportError:
        # psutil not installed, skip memory check
        return {"healthy": True, "message": "psutil not installed", "skipped": True}
    except Exception as e:
        return {"healthy": False, "message": str(e)}


def _get_version() -> str:
    """Get application version.

    Returns:
        Version string.
    """
    try:
        from smspanel.config import config

        env = getattr(config_dict, "FLASK_ENV", "unknown")
        return f"smspanel-{env}"
    except Exception:
        return "smspanel-unknown"


# Liveness probe (simple check that app is running)
@api_health_bp.route("/health/live", methods=["GET"])
def liveness():
    """Simple liveness probe.

    Returns:
        JSON response indicating if the app is alive.
    """
    return jsonify({"status": "alive"}), 200


# Readiness probe (check that app is ready to serve traffic)
@api_health_bp.route("/health/ready", methods=["GET"])
def readiness():
    """Readiness probe (includes database check).

    Returns:
        JSON response indicating if the app is ready.
    """
    db_healthy = _check_database()["healthy"]

    if db_healthy:
        return jsonify({"status": "ready"}), 200
    else:
        return jsonify({"status": "not ready", "reason": "Database not connected"}), 503
```

**Step 4: Update api/__init__.py**

Modify `src/smspanel/api/__init__.py`:

```python
"""API blueprint for RESTful endpoints."""

from flask import Blueprint

api_bp = Blueprint("api", __name__)

# Import routes to register them
from . import sms  # noqa: E402
from . import health  # noqa: E402

api_bp.register_blueprint(sms.api_sms_bp)
api_bp.register_blueprint(health.api_health_bp, url_prefix="/health")
```

**Step 5: Add psutil dependency**

Modify `pyproject.toml`:

```toml
dependencies = [
    ...
    "psutil>=5.9.0",  # Add this line
]
```

**Step 6: Run test after fix**

Run: `pytest tests/test_health.py -v`
Expected: PASS

**Step 7: Run full test suite**

Run: `pytest -v`
Expected: All tests pass

**Step 8: Commit**

```bash
git add src/smspanel/api/health.py src/smspanel/api/__init__.py pyproject.toml tests/test_health.py
git commit -m "feat: add health check endpoints for monitoring"
```

---

## Task 6: Run Full Test Suite and Lint

**Files:**
- N/A (verification task)

**Step 1: Run full test suite**

Run: `pytest -v`
Expected: All tests pass

**Step 2: Run linting**

Run: `ruff check .`
Expected: No errors

**Step 3: Run formatting**

Run: `ruff format .`
Expected: Code formatted

**Step 4: Commit**

```bash
git add src/ tests/ pyproject.toml
git commit -m "chore: run tests and lint after feature implementation"
```

---

## Task 7: Bump Version

**Files:**
- Modify: `pyproject.toml:3`

**Step 1: Update version**

From `0.23.0` to `0.24.0` (minor version for new features)

**Step 2: Commit**

```bash
git add pyproject.toml
git commit -m "chore: bump version to 0.24.0"
```

---

## Summary of Changes

| Task | Files Changed | Description |
|------|--------------|-------------|
| 1 | `models.py`, `scripts/...` | Add compound index on Message(user_id, created_at) |
| 2 | `admin_messages.py`, `messages.html`, `web/__init__.py` | Add admin message query UI with filters |
| 3 | `responses.py`, `decorators.py` | Standardize error responses to {error: {...}} format |
| 4 | `logging.py`, `app.py` | Add standardized error logging utilities |
| 5 | `health.py`, `api/__init__.py` | Add health check endpoints (/api/health, /api/health/live, /api/health/ready) |
| 6 | N/A | Run full test suite and lint |
| 7 | `pyproject.toml` | Bump version to 0.24.0 |

---

## Plan Complete

**Plan saved to:** `docs/plans/2026-01-21-features.md`

**Two execution options:**

1. **Subagent-Driven (this session)** - I dispatch fresh subagent per task, review between tasks, fast iteration

2. **Parallel Session (separate)** - Open new session with executing-plans, batch execution with checkpoints

Which approach?
